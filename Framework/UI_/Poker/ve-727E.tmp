// PokerTableWnd.cpp : implementation file
//

#include "stdafx.h"
#include "..\..\Controls\MercuryGUI.h"

#include "ChildControls\ESChildControlButton.h"
#include "ChildControls\ESChildControlShortcutBtn.h"
#include "ChildControls\ESChildControlSlider.h"
#include "ChildControls\ESChildControlPreAction.h"
#include "ChildControls\ESChildControlActionPanel.h"
#include "ChildControls\ESChildControlTable.h"
#include "ChildControls\ESChildControlSeat.h"
#include "ChildControls\ESChildControlChips.h"

#include "..\..\Controls\ESItemsList.h"
#include "..\..\Image\ImageHelper.h"
#include "..\..\Path\Path.h"
#include "PokerTableWnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// PokerTableWnd

PokerTableWnd::PokerTableWnd() : MercuryBaseView(){
	m_bUseForegroundColor	= 0;
	m_crForeground			= RGB(0, 0, 0);
	m_nAlpha				= 122;
	m_pGUI					= PokerGUI::GetInstance();
	m_currentRound			= PokerRoundType::No;
	m_fZoomFactor			= 1.0f;
	m_seatPanelInfos		= NULL;
	m_nRegularThinkTimeSec	= 20;
	m_pHandler				= NULL;

	m_nCard1				= -1;
	m_nCard2				= -1;
	m_nCard3				= -1;
	m_nCard4				= -1;
	m_nCard5				= -1;

	m_nActiveSeat			= -1;
	m_nDealerSeat			= 0;
	m_nTotalPotAmount		= 0;
	m_nMainPotAmount		= 0;

	// Acceptable max players count. ####
	m_acceptebleMaxPlayersCount.Add(2);
	m_acceptebleMaxPlayersCount.Add(4);
	m_acceptebleMaxPlayersCount.Add(6);
	m_acceptebleMaxPlayersCount.Add(9);
	m_acceptebleMaxPlayersCount.Add(10);
	// #################################
	}

IMPLEMENT_DYNCREATE(PokerTableWnd, MercuryBaseView)

PokerTableWnd::~PokerTableWnd(){
	}

BEGIN_MESSAGE_MAP(PokerTableWnd, MercuryBaseView)
	ON_WM_LBUTTONDOWN	()
	ON_WM_LBUTTONDBLCLK	()
	ON_WM_LBUTTONUP		()
	ON_MESSAGE			(WM_VSCROLL, OnVScroll)
	ON_MESSAGE			(WM_HSCROLL, OnHScroll)
	ON_WM_GETMINMAXINFO	()
	ON_WM_SIZE			()
	ON_WM_MOUSEWHEEL	()
	ON_WM_MOUSEMOVE		()
	ON_WM_KEYDOWN		()
	ON_WM_TIMER			()
	ON_MESSAGE			(WM_ACTION_BUTTON_CLICK, OnActionButtonClick)
	ON_MESSAGE			(WM_SHORTCUT_BUTTON_CLICK, OnShortcutButtonClick)
	ON_MESSAGE			(WM_SLIDER_POS_CHANGED, OnSliderPosChanged)
	ON_MESSAGE			(WM_PREACTION_CHECKED, OnPreActionChecked)
//	ON_WM_SETCURSOR		()
END_MESSAGE_MAP()

BOOL 
PokerTableWnd::Create(LPCTSTR lpszClassName,
						LPCTSTR lpszWindowName, DWORD dwStyle,
						const RECT& rect,
						CWnd* pParentWnd, UINT nID,
						CCreateContext* pContext /*= NULL*/){
	BOOL bRet =  CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
	if( bRet ){
		CreateChildControls();
		}
	return bRet;
	}

bool
PokerTableWnd::CreateChildControls(){
	CRect rcClient;
	GetClientRect(rcClient);

	// Action panel.
	ESChildControlActionPanel* pActionPanel = new ESChildControlActionPanel();
	CRect rcActionPanel = m_pGUI->m_rcActionPanel;
	AddChildControl(pActionPanel, CHILD_PokerActionPanel, rcActionPanel, NULL);

	// Table control.
	ESChildControlTable* pTable = new ESChildControlTable();
	AddChildControl(pTable, CHILD_PokerTable, CRect(0, 0, 1, 1), NULL);

	/*
	ESChildControlSeat* pSeat = new ESChildControlSeat();
	AddChildControl(pSeat, CHILD_Seat, CRect(0, 0, 1, 1), NULL);*/

	
/*
	// Pre-Actions
	AddPreActionButton(PreActionButton::PreAction_CheckFold, _T("Check/Fold"), true, false);
	AddPreActionButton(PreActionButton::PreAction_Check, _T("Check"), true, false);
	AddPreActionButton(PreActionButton::PreAction_Fold, _T("Fold"), true, false);
	AddPreActionButton(PreActionButton::PreAction_Call, _T("Call"), true, false);
	AddPreActionButton(PreActionButton::PreAction_CallAny, _T("Call Any"), true, false);
	AddPreActionButton(PreActionButton::PreAction_CallAnyCheck, _T("Call Any/Check"), true, false);
*/

/*
	// Action buttons.
	AddActionButton(ActionButton::ButtonFold, _T("Fold"), 0, 0, false);
	AddActionButton(ActionButton::ButtonCall, _T("Call"), 100, 100, false);
	AddActionButton(ActionButton::ButtonBet, _T("Raise"), 100, 10000, false);

	// Shortcut buttons.
	AddShortcutButton(_T("BB"), 100, false);
	AddShortcutButton(_T("2BB"), 200, false);
	AddShortcutButton(_T("3BB"), 300, false);
	AddShortcutButton(_T("5BB"), 500, false);
	AddShortcutButton(_T("ALLIN"), -1, false);

	// Slider
	ShowSlider(100, 100, 1000, 10, false);

	// Pre-Actions
	AddPreActionButton(PreActionButton::PreAction_AutoMuck, 0, _T("Auto Muck"), true, false);
	AddPreActionButton(PreActionButton::PreAction_AutoPostBB, 0, _T("Auto Post Blind"), true, false);
	AddPreActionButton(PreActionButton::PreAction_SitOutNextBB, 0, _T("Sit Out Next BB"), true, false);
	AddPreActionButton(PreActionButton::PreAction_SitOutNextHand, 0, _T("Sit Out Next Hand"), true, false);

	*/

//	AddPreActionButton(PreActionButton::PreAction_CheckFold, _T("Check/Fold"), true, false);
//	AddPreActionButton(PreActionButton::PreAction_Call, _T("Call 0.1"), true, false);
//	AddPreActionButton(PreActionButton::PreAction_CallAny, _T("Call Any"), true, false);

	EnumerableObject<PokerTableSeatInfo> seats;
	PokerTableSeatInfo* pSeatInfo = NULL;


	CImage* pAvatarImage = new CImage();

	// D:\\The_Incredible_Hulk_2.png

	CLongBinary bin;
	Serializable::LoadImageData(_T("D:\\The_Incredible_Hulk_2.png"), bin);

	for(int i=0; i<10; i++){
		pSeatInfo = new PokerTableSeatInfo();
		pSeatInfo->SetUserName	(_T("ZqrTalent"));
		pSeatInfo->SetActionName(_T("Call 0.4"));
		pSeatInfo->SetBalance	(5090);
		pSeatInfo->SetPotAmount	(1090);
		pSeatInfo->SetStatus	(PokerSeatStatus::Sitted);
		pSeatInfo->SetCard1		(10);
		pSeatInfo->SetCard2		(10);
		pSeatInfo->SetRankLevel	(4);
		pSeatInfo->SetAvatarData(&bin);

		seats.Add(pSeatInfo);
		}

	Setup(10, &seats, NULL, PokerRoundType::No, NULL);

	SetTableCards(10, 20, 30, 40, 50);
	
	return true;
	}

void
PokerTableWnd::OnPrePaint(CRect& rcRepaint){
	}

/*
void
PokerTableWnd::GetClientRectMy(CRect& rcClient){
	PokerGUI* pGUI = PokerGUI::GetInstance();
	rcClient.SetRect(0, 0, pGUI->m_szDefWindowSize.cx, pGUI->m_szDefWindowSize.cy);
	}*/

void 
PokerTableWnd::OnPaintClient(CDC* pDC, CRect* pRectDC, CRect* pRectClient){
	CRect rcClipDC = *pRectDC;
	CRect rcDestDC(-1*pRectClient->left, -1*pRectClient->top, pRectDC->Width(), pRectDC->Height());

	DrawFloor			(pDC, &rcDestDC, &rcClipDC);
	/*
	DrawTable			(pDC, pRectDC, pRectClient);
	DrawSeat			(-1, pDC, pRectDC, pRectClient); // Draw all seats.
	DrawMainPotChips	(pDC, pRectDC, pRectClient);
	DrawTotalPotAmount	(pDC, pRectDC, pRectClient);
	DrawTableCards		(pDC, pRectDC, pRectClient);*/

	RedrawChildControls	(pDC, pRectDC, pRectClient);
	}

void
PokerTableWnd::OnShowWindow(BOOL bShow, UINT nStatus){
	CWnd::OnShowWindow(bShow, nStatus);
	}

void
PokerTableWnd::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags){
	CWnd::OnChar(nChar, nRepCnt, nFlags);
	}

void
PokerTableWnd::OnSize(UINT nType, int cx, int cy){
	// Resize child controls.
	ResizeChildControls(cx, cy);

	CWnd::OnSize(nType, cx, cy);
	}

BOOL 
PokerTableWnd::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt){
	/*
	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	if( pState && m_pView )
		m_pView->SendMessage(pState->m_msgCur.message, pState->m_msgCur.wParam, pState->m_msgCur.lParam);
	*/
	return 1;
	}

void
PokerTableWnd::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags){
	_AFX_THREAD_STATE* pState = AfxGetThreadState();
	/*
	if( pState && m_pView )
		m_pView->SendMessage(pState->m_msgCur.message, pState->m_msgCur.wParam, pState->m_msgCur.lParam);
	else*/
	MercuryBaseView::OnKeyDown(nChar, nRepCnt, nFlags);
	}

UINT 
PokerTableWnd::OnGetDlgCode(){
	return DLGC_WANTALLKEYS|DLGC_WANTARROWS;
	}

LRESULT	
PokerTableWnd::OnVScroll(WPARAM wParam, LPARAM lParam){
	/*
	if( m_pView && IsWindow(*m_pView) ){
		BOOL bRet = (BOOL)m_pView->SendMessage(WM_VSCROLL, wParam, lParam);
		return bRet;
		}
	*/
	return FALSE;
	}

LRESULT	
PokerTableWnd::OnHScroll(WPARAM wParam, LPARAM lParam){
	/*
	if( m_pView && IsWindow(*m_pView) ){
		BOOL bRet = (BOOL)m_pView->SendMessage(WM_HSCROLL, wParam, lParam);
		return bRet;
		}
	*/
	return 0;
	}

BOOL
PokerTableWnd::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message){
	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
	}

void
PokerTableWnd::OnGetMinMaxInfo(MINMAXINFO* lpMMI){
	/*
	lpMMI->ptMinTrackSize.y = 200;
	MercuryBaseView::OnGetMinMaxInfo(lpMMI);
	*/
	}

void 
PokerTableWnd::OnMouseMove(UINT nFlags, CPoint point){
	MercuryBaseView::OnMouseMove(nFlags, point);
	}

BOOL 
PokerTableWnd::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message){
	return MercuryBaseView::OnSetCursor(pWnd, nHitTest, message);
	}

void 
PokerTableWnd::OnLButtonUp(UINT nFlags, CPoint point){
	// Seat panel click check. {{
	CRect rcSeat;
	int nSeat = 0;
	if( GetSeatPanelByPoint(point, nSeat, rcSeat) ){
		if( m_pHandler ){
			m_pHandler->OnSeatPanelClick(nSeat, GetSeatInfo(nSeat));
			}
		}
	// }}

	MercuryBaseView::OnLButtonUp(nFlags, point);
	}

void 
PokerTableWnd::OnLButtonDblClk(UINT nFlags, CPoint point){
	MercuryBaseView::OnLButtonDblClk(nFlags, point);
	}

void
PokerTableWnd::OnLButtonDown(UINT nFlags, CPoint point){
	m_bUseForegroundColor = FALSE;
	CRect rcRedraw (point.x - 40, point.y - 40, point.x + 40, point.y + 40);
	RedrawRect(rcRedraw, 1);
//	m_bUseForegroundColor = TRUE;

	//int nSeat = 0;
	//SetPotAmount(nSeat, GetPotAmount(nSeat) + 90);
	//Anim_CollectChips();

	/*
	CRect rcSeat;
	int nSeat = 0;
	if( GetSeatPanelByPoint(point, nSeat, rcSeat) ){
		SetupSeatTimer	(nSeat, 20, 0);
		SetActiveSeat	(nSeat, true, true);
		}*/

	MercuryBaseView::OnLButtonDown(nFlags, point);
	}

void
PokerTableWnd::OnTimer(UINT_PTR nIDEvent){
	if( nIDEvent == POKER_SEAT_ACTION_TIMER ){
		if( m_pTimerActiveSeat ){
			if( !m_pTimerActiveSeat->IncreaseTimer() ){
				KillTimer(POKER_SEAT_ACTION_TIMER);
				m_pTimerActiveSeat = NULL;
				// Time wasted.
				}
			else{
				Invalidate_SeatTimer(GetSeatIndex(m_pTimerActiveSeat));
				}
			}
		else{
			KillTimer(POKER_SEAT_ACTION_TIMER);
			}
		}
	MercuryBaseView::OnTimer(nIDEvent);
	}

// ######################################################
//
//	Operations.
//
// ######################################################

bool
PokerTableWnd::Setup(int nMaxPlayerCt, 
					EnumerableObject<PokerTableSeatInfo>* seats, 
					EnumerableObject<PokerAvatar>* seatAvatars,
					PokerRoundType round, 
					CDWordArray *pListTableCards,
					CString	sAmountLabelSufix /*= _T("GEL")*/)
	{
	// Set max player count. ######
	EnumerableObject<SeatPanelInfo>* ppSeatPanelInfos[] = 
			{&m_pGUI->m_seatInfo2, &m_pGUI->m_seatInfo4, 
			&m_pGUI->m_seatInfo6, &m_pGUI->m_seatInfo9, &m_pGUI->m_seatInfo10};

	int nIndex = m_acceptebleMaxPlayersCount.IndexOf(nMaxPlayerCt);
	if( nIndex == -1 ){
		nMaxPlayerCt = 2;
		nIndex = 0;
		}
	m_nMaxPlayerCt		= nMaxPlayerCt;
	m_seatPanelInfos	= ppSeatPanelInfos[nIndex];
	// ############################

	// Set seat info. #############
	m_seats.RemoveAll();

	ESChildControlTable* pTable = GetChildControl(CHILD_PokerTable);

	if( seats && seats->GetCount() > 0 ){
		for(int i=0; i<seats->GetCount(); i++){
			PokerTableSeatInfo* pSeatInfo = seats->GetAt(i);
			if( pSeatInfo ){
				PokerAvatar* pAvatarInfo = seatAvatars ? seatAvatars->GetAt(i) : NULL;
			//	pSeatInfo->SetAvatarData(pAvatarInfo ? &pAvatarInfo->m_binData : NULL);
				}

			// Create seat control. {{
			ESChildControlSeat* pSeat = new ESChildControlSeat();
			if( AddChildControl(pSeat, CHILD_Seat + i, CRect(0, 0, 1, 1), NULL) ){
				SeatPanelInfo* pSeatPanelInfo = m_seatPanelInfos->GetAt(i);
				if( pSeatPanelInfo ){
					float fPosX = (pSeatPanelInfo->m_ptPos.x / ((float)m_pGUI->m_szDefWindowSize.cx));
					float fPosY = (pSeatPanelInfo->m_ptPos.y / ((float)m_pGUI->m_szDefWindowSize.cy));
					float fCX	= (m_pGUI->m_szSeatPanel.cx / ((float)m_pGUI->m_szDefWindowSize.cx));
					float fCY	= (m_pGUI->m_szSeatPanel.cy / ((float)m_pGUI->m_szDefWindowSize.cy));

					pSeat->SetSeatIndex		(i);
					pSeat->SetSeatInfo		(pSeatInfo, false);
					pSeat->SetLogicalPos	(fPosX, fPosY);
					pSeat->SetLogicalSize	(fCX, fCY);
					}	
				}
			else
				delete pSeat;
			// }}

			m_seats.Add(pSeatInfo);
			}
		seats->RemoveAll(false);
		}
	// ############################

	// Set current round. #########
	m_currentRound	= round;
	m_nCard1		= -1;
	m_nCard2		= -1;
	m_nCard3		= -1;
	m_nCard4		= -1;
	m_nCard5		= -1;

	if( pListTableCards ){
		int* ppTableCards[] = {&m_nCard1, &m_nCard2, &m_nCard3, &m_nCard4, &m_nCard5};
		for(int i=0; i<max(pListTableCards->GetCount(), 5); i++){
			*ppTableCards[i] = pListTableCards->GetAt(i);
			}
		}
	// ############################
	m_sAmountLabelSuffix = sAmountLabelSufix;
	return true;
	}

int
PokerTableWnd::GetMaxPotAmount(){
	int nMaxPotAmount = 0;
	for( int i=0; i<m_seats.GetCount(); i++ ){
		PokerTableSeatInfo* pSeatInfo = m_seats.GetAt(i);
		if( pSeatInfo ){
			nMaxPotAmount = max(nMaxPotAmount, pSeatInfo->GetPotAmount());
			}
		}
	return nMaxPotAmount;
	}

bool
PokerTableWnd::SetSeatAvatarInfo(int nSeat, PokerAvatar* pAvatarInfo, bool bRedraw /*= true*/){
	PokerTableSeatInfo* pSeatInfo = GetSeatInfo(nSeat);
	if( !pSeatInfo )
		return false;

	pSeatInfo->SetAvatarData(pAvatarInfo ? &pAvatarInfo->m_binData : NULL);
	if( bRedraw ){
		Invalidate_SeatPanel(bRedraw);
		}
	return true;
	}

bool
PokerTableWnd::SetSeatInfo(int nSeatIndex, PokerTableSeatInfo* pInfo, bool bRedraw /*= true*/){
	if( nSeatIndex < 0 || nSeatIndex >= m_nMaxPlayerCt )
		return false;

	if( !m_seats.SetAt(nSeatIndex, pInfo, true) ){
		return false;
		}
	
	if( bRedraw ){
		Invalidate_SeatPanel(nSeatIndex);
		}
	return true;
	}

void
PokerTableWnd::SetRound(PokerRoundType round, CDWordArray *pListTableCards){
	m_currentRound = round;
	if( !pListTableCards ){
		m_nCard1 = -1;
		m_nCard2 = -1;
		m_nCard3 = -1;
		m_nCard4 = -1;
		m_nCard5 = -1;
		return;
		}

	int *pCards[] = {&m_nCard1, &m_nCard2, &m_nCard3, &m_nCard4, &m_nCard5};
	int nLoop = 0;
	int nCt = min(pListTableCards->GetCount(), 5);

	while( nLoop < nCt ){
		*pCards[nLoop] = (int)pListTableCards->GetAt(nLoop);
		nLoop ++;
		}
	}

bool
PokerTableWnd::SetupSeatTimer(int nSeat, int nFullSeconds, int nSecondsPassed, bool bInvalidate /*= false*/, bool bStart /*= false*/){
	PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
	if( !pSeat )
		return false;

	pSeat->SetupTimer(nFullSeconds, nSecondsPassed);
	// Start or stop action timer. {{
	StartActionTimer(nSeat, bStart, bInvalidate);
	// }}
	return true;
	}

void
PokerTableWnd::SetDealerSeat(int nSeatIndex, bool bInvalidate){
	int nDealerSeatOld = m_nDealerSeat;
	m_nDealerSeat = nSeatIndex;
	if( bInvalidate ){
		Invalidate_DealerBtn(nDealerSeatOld);
		}
	}

void		
PokerTableWnd::SetTableCards(int nCard1, int nCard2, int nCard3, int nCard4 /*= -1*/, int nCard5 /*= -1*/, bool bInvalidate /*= true*/){
	m_nCard1 = nCard1;
	m_nCard2 = nCard2;
	m_nCard3 = nCard3;
	m_nCard4 = nCard4;
	m_nCard5 = nCard5;

	if( bInvalidate ){
		CRect rcTableCards;
		if( GetTableCardsRect(rcTableCards) ){
			RedrawRect(rcTableCards, 1);
			}
		}
	}

// Set seat cards.
bool
PokerTableWnd::SetSeatCards(int nSeat, int nCard1, int nCard2, int nCard3, int nCard4, bool bInvalidate /*= true*/){
	PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
	if( !pSeat ) return false;

	pSeat->SetCard1(nCard1);
	pSeat->SetCard2(nCard2);
	pSeat->SetCard3(nCard3);
	pSeat->SetCard4(nCard4);
	
	if( bInvalidate ){
		Invalidate_SeatCards(nSeat);
		}
	return true;
	}


void		
PokerTableWnd::SetTotalPotAmount(int nTotalPotAmount, bool bRedraw){
	int nAmountOld = m_nTotalPotAmount;
	m_nTotalPotAmount = nTotalPotAmount;

	if( bRedraw ){
		Invalidate_TotalPot(nAmountOld);
		}
	}

void		
PokerTableWnd::SetMainPotAmount(int nMainPotAmount, bool bRedraw){
	int nAmountOld = m_nMainPotAmount;
	m_nMainPotAmount = nMainPotAmount;

	if( bRedraw ){
		Invalidate_MainPotChips(nAmountOld);
		}
	}

// ######################################################
//
//	Drawing methods.
//
// ######################################################

bool
PokerTableWnd::DrawFloor(CDC* pDC, CRect* pRectDC, CRect* pClipRect){
	ASSERT( pRectDC && pClipRect );

	CImage* pImage = m_pGUI->m_pFloorBgImg;
	if( pImage ){
		bool bRet = ImgHlp::DrawImage32bpp_Repeated(pDC, pImage, *pRectDC, *pClipRect);
		return bRet;
		}
	return false;
	}

bool
PokerTableWnd::DrawTable(CDC* pDC, CRect* pRectDC, CRect* pRectClient){
	ASSERT( pRectDC && pRectClient );

	CImage* pImage = m_pGUI->m_pTableBgImg;
	if( pImage ){
		CRect	rcImage		(0, 0, pImage->GetWidth(), pImage->GetHeight());
		CPoint	ptTable		= m_pGUI->m_ptTablePos; // Table position.
		CRect	rcTableDest (ptTable.x, ptTable.y, ptTable.x + rcImage.Width(), ptTable.y + rcImage.Height());
		CRect	rcSrc		(0, 0, rcImage.Width(), rcImage.Height());

		// Transform table destination coords into window coords. ##
		CRect	rcTableDestDC;
		rcTableDestDC.top		= (ptTable.y - pRectClient->top);
		rcTableDestDC.left		= (ptTable.x - pRectClient->left);
		rcTableDestDC.right		= rcTableDestDC.left + rcImage.Width();
		rcTableDestDC.bottom	= rcTableDestDC.top + rcImage.Height();
		// ##########################################################

		ImgHlp::DrawAlphaImage(pDC, *pImage, rcSrc.left, rcSrc.top, rcSrc.Width(), rcSrc.Height(), rcTableDestDC);
		return true;
		}
	return false;
	}	
bool
PokerTableWnd::DrawSeat(int nSeatIndex, CDC* pDC, CRect* pRectDC, CRect* pRectClient){
	ASSERT( pRectDC && pRectClient );
	CImage* pImage = m_pGUI->m_pSeatPanelBgImg;
	if( !pImage || !m_seatPanelInfos ) return false;

	// Draw player seats. {{
	int		nSeatPanelCX		= m_pGUI->m_pSeatPanelBgImg->GetWidth();
	int		nSeatPanelCY		= m_pGUI->m_pSeatPanelBgImg->GetHeight();
	int		nEmptyLogoCX		= m_pGUI->m_szEmptySeatLogo.cx;
	int		nEmptyLogoCY		= m_pGUI->m_szEmptySeatLogo.cy;
	int		nRankIndicatorCX	= m_pGUI->m_pRankImg->GetWidth();
	int		nRankIndicatorCY	= m_pGUI->m_pRankImg->GetHeight();
	int		nAvatarCX			= m_pGUI->m_szAvatar.cx;
	int		nAvatarCY			= m_pGUI->m_szAvatar.cy;
	int		nCardImageCX		= m_pGUI->m_szCardDimension.cx;
	int		nCardImageCY		= m_pGUI->m_szCardDimension.cy;
	int		nPBarImageCX		= m_pGUI->m_szProgressBar.cx;
	int		nPBarImageCY		= m_pGUI->m_szProgressBar.cy;
	int		nDealerImageCX		= m_pGUI->m_pDealerBtnImg->GetWidth();
	int		nDealerImageCY		= m_pGUI->m_pDealerBtnImg->GetHeight();

	CRect	rcDestDC, rcSrcImage, rcInvalid;
	int		nLoop		= 0;

	while( nLoop < m_seatPanelInfos->GetCount() ){
		// Skip seat(s) that we won't to draw. {{
		if( nSeatIndex != -1 && nSeatIndex != nLoop ){
			nLoop ++;
			continue;
			}
		// }}

		SeatPanelInfo*	pInfo = m_seatPanelInfos->GetAt(nLoop);
		PokerTableSeatInfo* pSeat = m_seats.GetAt(nLoop);
		if( !pInfo ){
			nLoop ++;
			continue;
			}

		CFont* pFontSeatLabel = m_pGUI->m_pSeatLabelFont;

		// Draw seat cards. {{
		if( pSeat ){
			CImage* pCardImages[] = { m_pGUI->GetCardImageByIndex(pSeat->GetCard1()),
									m_pGUI->GetCardImageByIndex(pSeat->GetCard2()),
									m_pGUI->GetCardImageByIndex(pSeat->GetCard3()),
									m_pGUI->GetCardImageByIndex(pSeat->GetCard4())};

			int nImagesCt		= 4;
			int i				= 0;
			int nCt				= 4;
			int	nDistanceCX		= (m_pGUI->m_ptSeatCard2Pos.x - m_pGUI->m_ptSeatCard1Pos.x);
			int nWidthImages	= ((nImagesCt - 1)*nDistanceCX + m_pGUI->m_szCardDimension.cx);
			int nCardPosX		= (m_pGUI->m_szSeatPanel.cx - nWidthImages) / 2;

			while( i < nCt ){
				if( !pCardImages[i] ){
					i ++;
					continue;
					}

				CImage* pCardImage	= pCardImages[i];
				CRect rcCardImg;
				rcCardImg.left		= pInfo->m_ptPos.x + nCardPosX;
				rcCardImg.top		= pInfo->m_ptPos.y + m_pGUI->m_ptSeatCard1Pos.y;
				rcCardImg.right		= rcCardImg.left + nCardImageCX;
				rcCardImg.bottom	= rcCardImg.top + nCardImageCY;

				rcInvalid = rcCardImg & *pRectClient;
				if( !rcInvalid.IsRectEmpty() ){
					rcSrcImage.left		= rcInvalid.left - rcCardImg.left;
					rcSrcImage.top		= rcInvalid.top - rcCardImg.top;
					rcSrcImage.right	= nCardImageCX;
					rcSrcImage.bottom	= nCardImageCY;

					rcDestDC.left		= (rcCardImg.left - pRectClient->left) < 0 ? 0 : (rcCardImg.left - pRectClient->left);
					rcDestDC.top		= (rcCardImg.top - pRectClient->top) < 0 ? 0 : (rcCardImg.top - pRectClient->top);
					rcDestDC.right		= rcDestDC.left + rcSrcImage.Width();
					rcDestDC.bottom		= rcDestDC.top + rcSrcImage.Height();

					if( pSeat->GetStatus() == PokerSeatStatus::Folded ){
						ImgHlp::DrawAlphaImage(pDC, *pCardImage, rcSrcImage.left, rcSrcImage.top, nCardImageCX, nCardImageCY, rcDestDC, TRUE, 122);
						}
					else
						ImgHlp::DrawAlphaImage(pDC, *pCardImage, rcSrcImage.left, rcSrcImage.top, nCardImageCX, nCardImageCY, rcDestDC);
					}

				nCardPosX += nDistanceCX;
				i ++;
				}
			}
		// }}

		// Draw seat panel background {{
		CRect rcDestPanel;
		rcDestPanel.left	= pInfo->m_ptPos.x;
		rcDestPanel.top		= pInfo->m_ptPos.y;
		rcDestPanel.right	= rcDestPanel.left + nSeatPanelCX;
		rcDestPanel.bottom	= rcDestPanel.top +nSeatPanelCY ;

		CPoint	ptPanelDestDC	(rcDestPanel.left - pRectClient->left,
								rcDestPanel.top - pRectClient->top);

		rcInvalid = rcDestPanel & *pRectClient;
		if( !rcInvalid.IsRectEmpty() ){
			rcSrcImage.SetRect(rcInvalid.left - rcDestPanel.left,
							rcInvalid.top - rcDestPanel.top, 
							nSeatPanelCX, nSeatPanelCY);

			rcDestDC.left	= (rcDestPanel.left - pRectClient->left) < 0 ? 0 : (rcDestPanel.left - pRectClient->left);
			rcDestDC.top	= (rcDestPanel.top - pRectClient->top) < 0 ? 0 : (rcDestPanel.top - pRectClient->top);
			rcDestDC.right	= rcDestDC.left + rcSrcImage.Width();
			rcDestDC.bottom	= rcDestDC.top + rcSrcImage.Height();

			// Draw panel background. {{
			CImage* pPanelBkgnd = m_pGUI->m_pSeatPanelBgImg;
			if( nLoop == m_nActiveSeat ){ // Active seat.
				pPanelBkgnd = m_pGUI->m_pSeatPanelActBgImg;
				if( pSeat && (pSeat->GetStatus() == PokerSeatStatus::SittedOut || pSeat->GetStatus() == PokerSeatStatus::Folded) ){
					pFontSeatLabel	= m_pGUI->m_pSeatLabelFontItalic;
					pPanelBkgnd		= m_pGUI->m_pSeatPanelBgDisImg;
					}
				}
			else{
				if( pSeat && (pSeat->GetStatus() == PokerSeatStatus::SittedOut || pSeat->GetStatus() == PokerSeatStatus::Folded) ){
					pFontSeatLabel	= m_pGUI->m_pSeatLabelFontItalic;
					pPanelBkgnd		= m_pGUI->m_pSeatPanelBgDisImg;
					}
				}
			
			ImgHlp::DrawAlphaImage(pDC, *pPanelBkgnd, 
					rcSrcImage.left, rcSrcImage.top, nSeatPanelCX, nSeatPanelCY, rcDestDC);
			// }}

			// Draw empty seat logo. {{
			if( !pSeat || pSeat->GetStatus() == PokerSeatStatus::Empty ){
				CRect rcDestLogo;
				rcDestLogo.left		= rcDestPanel.left + (nSeatPanelCX - nEmptyLogoCX)/2;
				rcDestLogo.top		= rcDestPanel.top + (nSeatPanelCY - nEmptyLogoCY)/2;
				rcDestLogo.right	= rcDestLogo.left + nEmptyLogoCX;
				rcDestLogo.bottom	= rcDestLogo.top + nEmptyLogoCY;
				rcInvalid			= rcDestLogo & *pRectClient;

				if( !rcInvalid.IsRectEmpty() ){
					rcSrcImage.SetRect(rcInvalid.left - rcDestLogo.left,
							rcInvalid.top - rcDestLogo.top, 
							nEmptyLogoCX, nEmptyLogoCY);

					rcDestDC.left	= (rcDestLogo.left - pRectClient->left) < 0 ? 0 : (rcDestLogo.left - pRectClient->left);
					rcDestDC.top	= (rcDestLogo.top - pRectClient->top) < 0 ? 0 : (rcDestLogo.top - pRectClient->top);
					rcDestDC.right	= rcDestDC.left + rcSrcImage.Width();
					rcDestDC.bottom	= rcDestDC.top + rcSrcImage.Height();

					ImgHlp::DrawAlphaImage(pDC, *m_pGUI->m_pEmptySeatLogo, 
							rcSrcImage.left, rcSrcImage.top, nEmptyLogoCX, nEmptyLogoCY, rcDestDC);
					}
				}
			// }}
			}

		// Draw dealer button. {{
		if( nLoop == m_nDealerSeat ){
	//	if( nLoop > -1 ){
			CRect rcDealerBtn;
			rcDealerBtn.left	= m_pGUI->m_ptTablePos.x + pInfo->m_ptDealerButtonPos.x;
			rcDealerBtn.top		= m_pGUI->m_ptTablePos.y + pInfo->m_ptDealerButtonPos.y;
			rcDealerBtn.right	= rcDealerBtn.left + nDealerImageCX;
			rcDealerBtn.bottom	= rcDealerBtn.top + nDealerImageCY;

			rcInvalid = rcDealerBtn & *pRectClient;
			if( !rcInvalid.IsRectEmpty() ){
				rcSrcImage.left		= rcInvalid.left - rcDealerBtn.left;
				rcSrcImage.top		= rcInvalid.top - rcDealerBtn.top;
				rcSrcImage.right	= nDealerImageCX;
				rcSrcImage.bottom	= nDealerImageCY;

				rcDestDC.left		= (rcDealerBtn.left - pRectClient->left) < 0 ? 0 : (rcDealerBtn.left - pRectClient->left);
				rcDestDC.top		= (rcDealerBtn.top - pRectClient->top) < 0 ? 0 : (rcDealerBtn.top - pRectClient->top);
				rcDestDC.right		= rcDestDC.left + rcSrcImage.Width();
				rcDestDC.bottom		= rcDestDC.top + rcSrcImage.Height();

				ImgHlp::DrawAlphaImage(pDC, *m_pGUI->m_pDealerBtnImg, rcSrcImage.left, rcSrcImage.top, nDealerImageCX, nDealerImageCY, rcDestDC);
				}
			}
		// }}

		if( !pSeat ){
			nLoop ++;
			continue;
			}
		// }}

		// Draw rank indicator. {{
		CRect rcRankIndicator;
		rcRankIndicator.left	= pInfo->m_ptPos.x + m_pGUI->m_ptRankIndicatorPos.x;
		rcRankIndicator.bottom	= (pInfo->m_ptPos.y + m_pGUI->m_ptRankIndicatorPos.y);
		rcRankIndicator.right	= rcRankIndicator.left + nRankIndicatorCX;
		rcRankIndicator.top		= rcRankIndicator.bottom - (pSeat->GetRankLevel()*nRankIndicatorCY);

		rcInvalid = rcRankIndicator & *pRectClient;
		if( !rcInvalid.IsRectEmpty() ){
			rcSrcImage.left		= rcInvalid.left - rcRankIndicator.left;
			rcSrcImage.top		= (rcInvalid.top - rcRankIndicator.top) % nRankIndicatorCY;
			rcSrcImage.right	= nRankIndicatorCX;
			rcSrcImage.bottom	= nRankIndicatorCY;

			rcDestDC.left		= (rcRankIndicator.left - pRectClient->left) < 0 ? 0 : (rcRankIndicator.left - pRectClient->left);
			rcDestDC.top		= (rcRankIndicator.top - pRectClient->top) < 0 ? 0 : (rcRankIndicator.top - pRectClient->top);
			rcDestDC.right		= rcDestDC.left + rcSrcImage.Width();
			rcDestDC.bottom		= rcDestDC.top + min(rcSrcImage.Height(), rcInvalid.Height());

			int nRank				= 0;
			int nHeightDrawed		= 0;
			while( nRank < pSeat->GetRankLevel() ){
				if( nHeightDrawed >= rcInvalid.Height() )
					break;

				ImgHlp::DrawAlphaImage(pDC, *m_pGUI->m_pRankImg, 
					rcSrcImage.left, rcSrcImage.top, nRankIndicatorCX, nRankIndicatorCY, rcDestDC);

				nHeightDrawed		+= rcDestDC.Height();
				rcDestDC.top		+= rcDestDC.Height();
				rcDestDC.bottom		= rcDestDC.top + min(nRankIndicatorCY, (rcInvalid.Height() - nHeightDrawed));

				rcSrcImage.top		= 0;
				nRank				++;
				}
			}
		// }}

		// Draw avatar. {{
		if( pSeat->GetAvatarImage() ){
			CRect rcAvatarImg;
			rcAvatarImg.left	= pInfo->m_ptPos.x + m_pGUI->m_ptAvatarPos.x;
			rcAvatarImg.top		= pInfo->m_ptPos.y + m_pGUI->m_ptAvatarPos.y;
			rcAvatarImg.right	= rcAvatarImg.left + nAvatarCX;
			rcAvatarImg.bottom	= rcAvatarImg.top + nAvatarCY;

			rcInvalid = rcAvatarImg & *pRectClient;
			if( !rcInvalid.IsRectEmpty() ){
				rcSrcImage.left		= rcInvalid.left - rcAvatarImg.left;
				rcSrcImage.top		= rcInvalid.top - rcAvatarImg.top;
				rcSrcImage.right	= nAvatarCX;
				rcSrcImage.bottom	= nAvatarCY;

				rcDestDC.left		= (rcAvatarImg.left - pRectClient->left) < 0 ? 0 : (rcAvatarImg.left - pRectClient->left);
				rcDestDC.top		= (rcAvatarImg.top - pRectClient->top) < 0 ? 0 : (rcAvatarImg.top - pRectClient->top);
				rcDestDC.right		= rcDestDC.left + rcSrcImage.Width();
				rcDestDC.bottom		= rcDestDC.top + rcSrcImage.Height();

				if( pSeat->GetStatus() == PokerSeatStatus::Folded ) // Draw blend avatar image.
					ImgHlp::DrawAlphaImage(pDC, *pSeat->GetAvatarImage(), rcSrcImage.left, rcSrcImage.top, nAvatarCX, nAvatarCY, rcDestDC, TRUE, 122);
				else
					ImgHlp::DrawAlphaImage(pDC, *pSeat->GetAvatarImage(), rcSrcImage.left, rcSrcImage.top, nAvatarCX, nAvatarCY, rcDestDC, FALSE);
				}
			}
		// }}

		// Draw timer. {{
		if( pSeat->IsTimerActive() ){
			CRect rcTimerPBar;
			rcTimerPBar.left	= pInfo->m_ptPos.x + m_pGUI->m_ptProgressBarPos.x;
			rcTimerPBar.top		= pInfo->m_ptPos.y + m_pGUI->m_ptProgressBarPos.y;
			rcTimerPBar.right	= rcTimerPBar.left + nPBarImageCX;
			rcTimerPBar.bottom	= rcTimerPBar.top + nPBarImageCY;

			rcInvalid = rcTimerPBar & *pRectClient;
			if( !rcInvalid.IsRectEmpty() ){
				rcSrcImage.left		= rcInvalid.left - rcTimerPBar.left;
				rcSrcImage.top		= rcInvalid.top - rcTimerPBar.top;
				rcSrcImage.right	= nPBarImageCX;
				rcSrcImage.bottom	= nPBarImageCY;

				rcDestDC.left		= (rcTimerPBar.left - pRectClient->left) < 0 ? 0 : (rcTimerPBar.left - pRectClient->left);
				rcDestDC.top		= (rcTimerPBar.top - pRectClient->top) < 0 ? 0 : (rcTimerPBar.top - pRectClient->top);
				rcDestDC.right		= rcDestDC.left + rcSrcImage.Width();
				rcDestDC.bottom		= rcDestDC.top + rcSrcImage.Height();

				ImgHlp::DrawAlphaImage(pDC, *m_pGUI->m_pPBarBgImg, rcSrcImage.left, rcSrcImage.top, 
					nPBarImageCX, nPBarImageCY, rcDestDC);

				// Draw filled progress bar. {{
				int nAllSeconds		= pSeat->GetAllSeconds		();
				int nSecondsPassed	= pSeat->GetPassedSeconds	();

				float fDiv			= (nSecondsPassed / ((float)nAllSeconds));
				int	nFillWidth		= nPBarImageCX - (int)(fDiv * nPBarImageCX);
				
				rcSrcImage.left		= rcInvalid.left - rcTimerPBar.left;
				rcSrcImage.top		= rcInvalid.top - rcTimerPBar.top;
				rcSrcImage.right	= nFillWidth;
				rcSrcImage.bottom	= nPBarImageCY;

				rcDestDC.left		= (rcTimerPBar.left - pRectClient->left) < 0 ? 0 : (rcTimerPBar.left - pRectClient->left);
				rcDestDC.top		= (rcTimerPBar.top - pRectClient->top) < 0 ? 0 : (rcTimerPBar.top - pRectClient->top);
				rcDestDC.right		= rcDestDC.left + min(nFillWidth, rcSrcImage.Width());
				rcDestDC.bottom		= rcDestDC.top + rcSrcImage.Height();

				ImgHlp::DrawAlphaImage(pDC, *m_pGUI->m_pPBarFillImg, rcSrcImage.left, rcSrcImage.top, 
					nPBarImageCX, nPBarImageCY, rcDestDC);
				// }}
				/*
				// Timer seconds
				CPoint ptSec;
				ptSec.SetPoint	(ptPanelDestDC.x + m_pGUI->m_ptProgressBarPos.x + nPBarImageCX + 2, 
								ptPanelDestDC.y + m_pGUI->m_ptProgressBarPos.y - 5);
				CString sSec;
				sSec.Format(_T("%d"), nAllSeconds - nSecondsPassed);
				CFont* pFontOld = pDC->SelectObject(pFontSeatLabel);
				pDC->SetBkMode		(TRANSPARENT);
				pDC->SetTextColor	(m_pGUI->m_crSeatUserNameLabel);
				pDC->ExtTextOut		(ptSec.x, ptSec.y, ETO_CLIPPED, pRectDC, sSec.GetBuffer(), NULL);
				pDC->SelectObject(pFontOld);
				*/
				}
			}
		// }}

		// Draw user name, balance and last action labels. {{
		CPoint ptLabel;
		CFont* pFontOld = pDC->SelectObject(pFontSeatLabel);

		CString sBalance;
		int		nBalance	= pSeat->GetBalance();
		int		nTotalPot	= pSeat->GetTotalPot();

		sBalance.Format		(_T("%d.%02d / %d.%02d %s"), nBalance/100, nBalance%100, nTotalPot/100, nTotalPot%100, m_sAmountLabelSuffix);
		pDC->SetBkMode		(TRANSPARENT);
		
		// User name.
		if( pSeat->GetUserName().GetLength() > 0 ){
			ptLabel.SetPoint	(ptPanelDestDC.x + m_pGUI->m_ptSeatUserNameLabel.x, 
								ptPanelDestDC.y + m_pGUI->m_ptSeatUserNameLabel.y);
			pDC->SetTextColor	(m_pGUI->m_crSeatUserNameLabel);
			pDC->ExtTextOut		(ptLabel.x, ptLabel.y, ETO_CLIPPED, pRectDC, pSeat->GetUserName().GetBuffer(), NULL);
			}
	
		// User balance.
		ptLabel.SetPoint	(ptPanelDestDC.x + m_pGUI->m_ptSeatBalanceLabel.x, 
							ptPanelDestDC.y + m_pGUI->m_ptSeatBalanceLabel.y);
		pDC->SetTextColor	(m_pGUI->m_crSeatBalanceLabel);
		pDC->ExtTextOut		(ptLabel.x, ptLabel.y, ETO_CLIPPED, pRectDC, sBalance.GetBuffer(), NULL);

		// User's last action.
		CString sActionName = pSeat->GetActionName();
		if( pSeat->IsOffline() ){
			sActionName = _T("Offline");
			}

		if( sActionName.GetLength() > 0 ){
			ptLabel.SetPoint	(ptPanelDestDC.x + m_pGUI->m_ptSeatActionLabel.x, 
								 ptPanelDestDC.y + m_pGUI->m_ptSeatActionLabel.y);
			pDC->SetTextColor	(m_pGUI->m_crSeatActionLabel);
			pDC->ExtTextOut		(ptLabel.x, ptLabel.y, ETO_CLIPPED, pRectDC, sActionName, NULL);
			}
		pDC->SelectObject	(pFontOld);
		// }}

		// Draw seat chips. {{
		DrawSeatChips(nLoop, pDC, pRectDC, pRectClient);
		// }}
		nLoop ++;
		}
	// }}
	return true;
	}

bool
PokerTableWnd::DrawSeatChips(int nSeatIndex, CDC* pDC, CRect* pRectDC, CRect* pRectClient){
	if( !m_seatPanelInfos )
		return false;

	PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeatIndex);
	SeatPanelInfo*	pInfo = m_seatPanelInfos->GetAt(nSeatIndex);
	if( !pInfo || !pSeat)
		return false;

	int nChipImageCX	= m_pGUI->m_szChipImage.cx;
	int nChipImageCY	= m_pGUI->m_szChipImage.cy;

	CRect rcDestChip, rcDestDC;
	rcDestChip.left		= pInfo->m_ptChipPos.x;
	rcDestChip.top		= pInfo->m_ptChipPos.y;
	rcDestChip.right	= rcDestChip.left + nChipImageCX;
	rcDestChip.bottom	= rcDestChip.top + nChipImageCY;

	CPoint ptChipPosDestDC((rcDestChip.left - pRectClient->left), (rcDestChip.top - pRectClient->top));
	CRect rcInvalid, rcSrcImage;
	
	// Draw chips. {{
	CPtrArray arrCurrChipImages;
	if( m_pGUI->GetChipImagesByAmount(pSeat->GetPotAmount(), arrCurrChipImages) > 0 ){
		int nChipImg		= 0;
		int nChipImageInRow = 0;
		int	nChipRow		= 0;
		while( nChipImg < arrCurrChipImages.GetCount() ){
			if( nChipImageInRow >= m_pGUI->m_nChipCountInCol ){
				nChipImageInRow = 0;
				nChipRow	++;
				}

			rcDestChip.left		= pInfo->m_ptChipPos.x + nChipRow*(nChipImageCX + 3);
			rcDestChip.top		= pInfo->m_ptChipPos.y - nChipImageInRow*3;
			rcDestChip.right	= rcDestChip.left + nChipImageCX;
			rcDestChip.bottom	= rcDestChip.top + nChipImageCY;

			rcInvalid = rcDestChip & *pRectClient;
			if( !rcInvalid.IsRectEmpty() ){
				rcSrcImage.left		= (rcInvalid.left - rcDestChip.left);
				rcSrcImage.top		= (rcInvalid.top - rcDestChip.top);
				rcSrcImage.right	= nChipImageCX;
				rcSrcImage.bottom	= nChipImageCY;

				rcDestDC.left	= (rcDestChip.left - pRectClient->left) < 0 ? 0 : (rcDestChip.left - pRectClient->left);
				rcDestDC.top	= (rcDestChip.top - pRectClient->top) < 0 ? 0 : (rcDestChip.top - pRectClient->top);
				rcDestDC.right	= rcDestDC.left + rcSrcImage.Width();
				rcDestDC.bottom	= rcDestDC.top + rcSrcImage.Height();
				
				ImgHlp::DrawAlphaImage(pDC, *((CImage*)arrCurrChipImages[nChipImg]), 
					rcSrcImage.left, rcSrcImage.top, nChipImageCX, nChipImageCY, rcDestDC);
				}
			nChipImg ++; nChipImageInRow ++;
			}
		// }}

		// Draw chip amount label. {{
		CPoint ptLabel(ptChipPosDestDC.x, ptChipPosDestDC.y + nChipImageCY + 2);
		CFont* pFontOld = pDC->SelectObject(m_pGUI->m_pChipLabelFont);

		CString sLabel;
		sLabel.Format(_T("%d.%02d %s"), pSeat->GetPotAmount() / 100, pSeat->GetPotAmount() % 100, m_sAmountLabelSuffix);

		pDC->SetBkMode		(TRANSPARENT);
		pDC->SetTextColor	(m_pGUI->m_crChipLabel);
		pDC->ExtTextOut		(ptLabel.x, ptLabel.y, ETO_CLIPPED, pRectDC, sLabel.GetBuffer(), NULL);
		pDC->SelectObject	(pFontOld);
		// }}
		return true;
		}
	return false;
	}

bool
PokerTableWnd::DrawTotalPotAmount(CDC* pDC, CRect* pRectDC, CRect* pRectClient){
	if( m_nTotalPotAmount <= 0 )
		return false;

	CPoint ptPosDestDC((m_pGUI->m_ptTotalPotLabelPos.x - pRectClient->left), (m_pGUI->m_ptTotalPotLabelPos.y - pRectClient->top));
	// Draw chip amount label. {{
	CPoint ptLabel(ptPosDestDC.x, ptPosDestDC.y);
	CFont* pFontOld = pDC->SelectObject(m_pGUI->m_pTotalPotLabelFont);

	CString sLabel;
	sLabel.Format(_T("Total Pot: %d.%02d %s"), m_nTotalPotAmount / 100, m_nTotalPotAmount % 100, m_sAmountLabelSuffix);

	pDC->SetBkMode		(TRANSPARENT);
	pDC->SetTextColor	(m_pGUI->m_crTotalPotLabel);
	pDC->ExtTextOut		(ptLabel.x, ptLabel.y, ETO_CLIPPED, pRectDC, sLabel.GetBuffer(), NULL);
	pDC->SelectObject	(pFontOld);
	// }}
	return true;
	}

bool
PokerTableWnd::DrawMainPotChips(CDC* pDC, CRect* pRectDC, CRect* pRectClient){
	int nAmount			= m_nMainPotAmount;
	int nChipImageCX	= m_pGUI->m_szChipImage.cx;
	int nChipImageCY	= m_pGUI->m_szChipImage.cy;

	CRect rcDestChip, rcDestDC;
	rcDestChip.left		= m_pGUI->m_ptTablePos.x + m_pGUI->m_ptMainPotChipsPos.x;
	rcDestChip.top		= m_pGUI->m_ptTablePos.y + m_pGUI->m_ptMainPotChipsPos.y;
	rcDestChip.right	= rcDestChip.left + nChipImageCX;
	rcDestChip.bottom	= rcDestChip.top + nChipImageCY;

	CPoint ptChipPosDestDC((rcDestChip.left - pRectClient->left), (rcDestChip.top - pRectClient->top));
	CRect rcInvalid, rcSrcImage;
	
	// Draw chips. {{
	CPtrArray arrCurrChipImages;
	if( m_pGUI->GetChipImagesByAmount(nAmount, arrCurrChipImages) > 0 ){
		int nChipImg		= 0;
		int nChipImageInRow = 0;
		int	nChipRow		= 0;
		while( nChipImg < arrCurrChipImages.GetCount() ){
			if( nChipImageInRow >= m_pGUI->m_nChipCountInCol ){
				nChipImageInRow = 0;
				nChipRow	++;
				}

			rcDestChip.left		= (m_pGUI->m_ptTablePos.x + m_pGUI->m_ptMainPotChipsPos.x) + nChipRow*(nChipImageCX + 3);
			rcDestChip.top		= (m_pGUI->m_ptTablePos.y + m_pGUI->m_ptMainPotChipsPos.y) - nChipImageInRow*3;
			rcDestChip.right	= rcDestChip.left + nChipImageCX;
			rcDestChip.bottom	= rcDestChip.top + nChipImageCY;

			rcInvalid = rcDestChip & *pRectClient;
			if( !rcInvalid.IsRectEmpty() ){
				rcSrcImage.left		= (rcInvalid.left - rcDestChip.left);
				rcSrcImage.top		= (rcInvalid.top - rcDestChip.top);
				rcSrcImage.right	= nChipImageCX;
				rcSrcImage.bottom	= nChipImageCY;

				rcDestDC.left	= (rcDestChip.left - pRectClient->left) < 0 ? 0 : (rcDestChip.left - pRectClient->left);
				rcDestDC.top	= (rcDestChip.top - pRectClient->top) < 0 ? 0 : (rcDestChip.top - pRectClient->top);
				rcDestDC.right	= rcDestDC.left + rcSrcImage.Width();
				rcDestDC.bottom	= rcDestDC.top + rcSrcImage.Height();
				
				ImgHlp::DrawAlphaImage(pDC, *((CImage*)arrCurrChipImages[nChipImg]), 
					rcSrcImage.left, rcSrcImage.top, nChipImageCX, nChipImageCY, rcDestDC);
				}
			nChipImg ++; nChipImageInRow ++;
			}
		// }}

		// Draw chip amount label. {{
		CPoint ptLabel(ptChipPosDestDC.x, ptChipPosDestDC.y + nChipImageCY + 2);
		CFont* pFontOld = pDC->SelectObject(m_pGUI->m_pMainPotLabelFont);

		CString sLabel;
		sLabel.Format(_T("Main Pot: %d.%02d %s"), nAmount / 100, nAmount % 100, m_sAmountLabelSuffix);

		pDC->SetBkMode		(TRANSPARENT);
		pDC->SetTextColor	(m_pGUI->m_crMainPotLabel);
		pDC->ExtTextOut		(ptLabel.x, ptLabel.y, ETO_CLIPPED, pRectDC, sLabel.GetBuffer(), NULL);
		pDC->SelectObject	(pFontOld);
		// }}
		return true;
		}
	return false;
	}

bool
PokerTableWnd::DrawTableCards(CDC* pDC, CRect* pRectDC, CRect* pRectClient){
	int		nCardImageCX	= m_pGUI->m_szCardDimension.cx;
	int		nCardImageCY	= m_pGUI->m_szCardDimension.cy;
	CRect	rcDestDC, rcSrcImage, rcInvalid, rcCardImg;
	CImage* pCardImage;

	// Draw table cards. {{
	CImage* pImages[] = {m_pGUI->GetCardImageByIndex(m_nCard1),
						m_pGUI->GetCardImageByIndex(m_nCard2), 
						m_pGUI->GetCardImageByIndex(m_nCard3),
						m_pGUI->GetCardImageByIndex(m_nCard4),
						m_pGUI->GetCardImageByIndex(m_nCard5)
						};

	CPoint* ptPos[] =	{&m_pGUI->m_ptTableCard1,
						&m_pGUI->m_ptTableCard2,
						&m_pGUI->m_ptTableCard3,
						&m_pGUI->m_ptTableCard4,
						&m_pGUI->m_ptTableCard5
						};

	for(int i=0; i<sizeof(pImages)/sizeof(void*); i++){
		pCardImage = pImages[i];
		if( pCardImage ){
			rcCardImg.left		= m_pGUI->m_ptTablePos.x + ptPos[i]->x;
			rcCardImg.top		= m_pGUI->m_ptTablePos.y + ptPos[i]->y;
			rcCardImg.right		= rcCardImg.left + nCardImageCX;
			rcCardImg.bottom	= rcCardImg.top + nCardImageCY;

			rcInvalid = rcCardImg & *pRectClient;
			if( !rcInvalid.IsRectEmpty() ){
				rcSrcImage.left		= rcInvalid.left - rcCardImg.left;
				rcSrcImage.top		= rcInvalid.top - rcCardImg.top;
				rcSrcImage.right	= nCardImageCX;
				rcSrcImage.bottom	= nCardImageCY;

				rcDestDC.left		= (rcCardImg.left - pRectClient->left) < 0 ? 0 : (rcCardImg.left - pRectClient->left);
				rcDestDC.top		= (rcCardImg.top - pRectClient->top) < 0 ? 0 : (rcCardImg.top - pRectClient->top);
				rcDestDC.right		= rcDestDC.left + rcSrcImage.Width();
				rcDestDC.bottom		= rcDestDC.top + rcSrcImage.Height();

				ImgHlp::DrawAlphaImage(pDC, *pCardImage, rcSrcImage.left, rcSrcImage.top, nCardImageCX, nCardImageCY, rcDestDC);
				}
			}
		}
	return true;
	}

// ######################################################
//
//	Animation methods.
//
// ######################################################
int
PokerTableWnd::GetChipSize(int nAmount, CSize& szChips){
	szChips.SetSize(0, 0);

	CPtrArray arrCurrChipImages;
	if( m_pGUI->GetChipImagesByAmount(nAmount, arrCurrChipImages) <= 0 )
		return 0;

	int nChipImageCX	= m_pGUI->m_szChipImage.cx;
	int nChipImageCY	= m_pGUI->m_szChipImage.cy;

	int nChipImagesCt	= arrCurrChipImages.GetCount();
	int nChipColsCt		= (nChipImagesCt / m_pGUI->m_nChipCountInCol) + (nChipImagesCt%m_pGUI->m_nChipCountInCol > 0 ? 1 : 0);
	int	nChipRowCt		= nChipColsCt > 1 ? m_pGUI->m_nChipCountInCol : nChipImagesCt;

	szChips.cy		= nChipImageCY + nChipRowCt*3;
	szChips.cx		= nChipImageCX + (nChipColsCt - 1)*(nChipImageCX + 3);
	return (int)arrCurrChipImages.GetCount();
	}

bool
PokerTableWnd::GetDealerButtonRect(int nSeat, CRect& rcDealerButton){
	if( !m_seatPanelInfos )
		return false;
	SeatPanelInfo*	pSeatPanel	= m_seatPanelInfos->GetAt(nSeat);
	if( !pSeatPanel || !m_pGUI->m_pDealerBtnImg )
		return false;

	rcDealerButton.left		= pSeatPanel->m_ptDealerButtonPos.x + m_pGUI->m_ptTablePos.x;
	rcDealerButton.top		= pSeatPanel->m_ptDealerButtonPos.y + m_pGUI->m_ptTablePos.y;
	rcDealerButton.right	= rcDealerButton.left + m_pGUI->m_pDealerBtnImg->GetWidth();
	rcDealerButton.bottom	= rcDealerButton.top + m_pGUI->m_pDealerBtnImg->GetHeight();
	return true;
	}

bool
PokerTableWnd::GetTableCardsRect(CRect& rcTableCards){
	rcTableCards.left		= m_pGUI->m_ptTableCard1.x;
	rcTableCards.top		= m_pGUI->m_ptTableCard1.y;
	rcTableCards.right		= m_pGUI->m_ptTableCard5.x + m_pGUI->m_szCardDimension.cx;
	rcTableCards.bottom		= rcTableCards.top + m_pGUI->m_szCardDimension.cy;
	return true;
	}

bool
PokerTableWnd::Invalidate_Chips(int nSeat, int nAmountOld /*= 0*/){
	if( !m_seatPanelInfos )
		return false;

	PokerTableSeatInfo* pSeat		= m_seats.GetAt(nSeat);
	SeatPanelInfo*	pSeatPanel	= m_seatPanelInfos->GetAt(nSeat);
	if( !pSeatPanel || !pSeat )
		return false;

	int nChipImageCX	= m_pGUI->m_szChipImage.cx;
	int nChipImageCY	= m_pGUI->m_szChipImage.cy;

	CSize	szChipsOld, szChips, szChipsRedrawArea;
	GetChipSize(nAmountOld, szChipsOld);
	GetChipSize(pSeat->GetPotAmount(), szChips);

	szChipsRedrawArea.cx = max(szChipsOld.cx, szChips.cx);
	szChipsRedrawArea.cy = max(szChipsOld.cy, szChips.cy);

	CString sLabel;
	sLabel.Format(_T("%d.%02d %s"), pSeat->GetPotAmount() / 100, pSeat->GetPotAmount() % 100, m_sAmountLabelSuffix);

	CSize szLabel;
	ImgHlp::GetTextSize(&sLabel, m_pGUI->m_pChipLabelFont, szLabel);
	
	CRect rcDestChip;
	rcDestChip.left		= pSeatPanel->m_ptChipPos.x;
	rcDestChip.top		= pSeatPanel->m_ptChipPos.y - (szChipsRedrawArea.cy- nChipImageCY);
	rcDestChip.right	= rcDestChip.left + szChipsRedrawArea.cx;
	rcDestChip.bottom	= rcDestChip.top + szChipsRedrawArea.cy + szLabel.cy;

	if( szLabel.cx > rcDestChip.Width() )
		rcDestChip.right = rcDestChip.left + szLabel.cx;

	//m_bUseForegroundColor = FALSE;
	RedrawRect(rcDestChip, 1);
	//m_bUseForegroundColor = TRUE;
	return true;
	}

bool
PokerTableWnd::Invalidate_Balance(int nSeat){
	if( !m_seatPanelInfos )
		return false;

	PokerTableSeatInfo* pSeat		= m_seats.GetAt(nSeat);
	SeatPanelInfo*	pSeatPanel	= m_seatPanelInfos->GetAt(nSeat);
	if( !pSeatPanel || !pSeat )
		return false;

	CSize	szText;
	CString	sBalance = _T("########.##");
	ImgHlp::GetTextSize(&sBalance, m_pGUI->m_pSeatLabelFont, szText);

	CRect rcBalanceRect;
	rcBalanceRect.left		= m_pGUI->m_ptTablePos.x + pSeatPanel->m_ptPos.x + m_pGUI->m_ptSeatBalanceLabel.x;
	rcBalanceRect.top		= m_pGUI->m_ptTablePos.y + pSeatPanel->m_ptPos.y + m_pGUI->m_ptSeatBalanceLabel.y;
	rcBalanceRect.right		= rcBalanceRect.left + szText.cx;
	rcBalanceRect.bottom	= rcBalanceRect.top + szText.cy;

	RedrawRect(rcBalanceRect, 1);
	return true;
	}

bool
PokerTableWnd::Invalidate_TotalPot(int nAmountOld /*= 0*/){
	CString sLabel;
	sLabel.Format(_T("Total Pot: %d.%02d %s"), m_nTotalPotAmount / 100, m_nTotalPotAmount % 100, m_sAmountLabelSuffix);

	CString sLabelOld;
	sLabelOld.Format(_T("Total Pot: %d.%02d %s"), nAmountOld / 100, nAmountOld % 100, m_sAmountLabelSuffix);

	CSize szLabel;
	ImgHlp::GetTextSize(&sLabel, m_pGUI->m_pTotalPotLabelFont, szLabel);

	CSize szLabelOld;
	ImgHlp::GetTextSize(&sLabel, m_pGUI->m_pTotalPotLabelFont, szLabelOld);

	szLabel.cx = max(szLabel.cx, szLabelOld.cx); 
	szLabel.cy = max(szLabel.cy, szLabelOld.cy); 
	
	CRect rcTotalPot;
	rcTotalPot.left		= m_pGUI->m_ptTotalPotLabelPos.x;
	rcTotalPot.top		= m_pGUI->m_ptTotalPotLabelPos.y;
	rcTotalPot.right	= rcTotalPot.left + szLabel.cx;
	rcTotalPot.bottom	= rcTotalPot.top + szLabel.cy;

	RedrawRect(rcTotalPot, 1);
	return true;
	}

bool
PokerTableWnd::Invalidate_MainPotChips(int nAmountOld /*= 0*/){
	int nChipImageCX	= m_pGUI->m_szChipImage.cx;
	int nChipImageCY	= m_pGUI->m_szChipImage.cy;

	CSize	szChipsOld, szChips, szChipsRedrawArea;
	GetChipSize(nAmountOld, szChipsOld);
	GetChipSize(m_nMainPotAmount, szChips);

	szChipsRedrawArea.cx = max(szChipsOld.cx, szChips.cx);
	szChipsRedrawArea.cy = max(szChipsOld.cy, szChips.cy);

	CString sLabel;
	sLabel.Format(_T("Main Pot: %d.%02d %s"), m_nMainPotAmount / 100, m_nMainPotAmount % 100, m_sAmountLabelSuffix);

	CSize szLabel;
	ImgHlp::GetTextSize(&sLabel, m_pGUI->m_pMainPotLabelFont, szLabel);
	
	CRect rcDestChip;
	rcDestChip.left		= m_pGUI->m_ptMainPotChipsPos.x;
	rcDestChip.top		= m_pGUI->m_ptMainPotChipsPos.y - (szChipsRedrawArea.cy - nChipImageCY);
	rcDestChip.right	= rcDestChip.left + szChipsRedrawArea.cx;
	rcDestChip.bottom	= rcDestChip.top + szChipsRedrawArea.cy + szLabel.cy;

	if( szLabel.cx > rcDestChip.Width() )
		rcDestChip.right = rcDestChip.left + szLabel.cx;

	//m_bUseForegroundColor = FALSE;
	RedrawRect(rcDestChip, 1);
	//m_bUseForegroundColor = TRUE;
	return true;
	}

bool
PokerTableWnd::Invalidate_SeatPanel(int nSeat){
	CRect rcSeatPanel;
	if( !GetSeatPanelRect(nSeat, rcSeatPanel) )
		return false;

//	m_bUseForegroundColor = FALSE;
	RedrawRect(rcSeatPanel, 1);
//	m_bUseForegroundColor = TRUE;
	return true;
	}

bool
PokerTableWnd::Invalidate_SeatTimer(int nSeat){
	CRect rcSeatPanel;
	if( !GetSeatPanelRect(nSeat, rcSeatPanel) )
		return false;

	CRect rcTimerProgress;
	rcTimerProgress.left	= rcSeatPanel.left + m_pGUI->m_ptProgressBarPos.x;
	rcTimerProgress.top		= rcSeatPanel.top + m_pGUI->m_ptProgressBarPos.y - 5;
	rcTimerProgress.right	= rcTimerProgress.left + m_pGUI->m_szProgressBar.cx;
	rcTimerProgress.bottom	= rcTimerProgress.top + m_pGUI->m_szProgressBar.cy + 5;

	//m_bUseForegroundColor = FALSE;
	RedrawRect(rcTimerProgress, 1);
	//m_bUseForegroundColor = TRUE;
	return true;
	}

bool
PokerTableWnd::Invalidate_DealerBtn(int nSeatDealerOld){
	CRect rcDealerBtn;
	if( GetDealerButtonRect(nSeatDealerOld, rcDealerBtn) ){
		RedrawRect(rcDealerBtn, 1);
		}
	if( GetDealerButtonRect(m_nDealerSeat, rcDealerBtn) ){
		RedrawRect(rcDealerBtn, 1);
		return true;
		}
	return false;
	}

bool
PokerTableWnd::Invalidate_SeatCards(int nSeat){
	CRect rcSeatCards;
	if( GetSeatCardsRect(nSeat, rcSeatCards) ){
		RedrawRect(rcSeatCards, 1);
		return true;
		}
	return false;
	}

int
PokerTableWnd::GetPotAmount(int nSeat){
	PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
	if( !pSeat )
		return 0;
	return pSeat->GetPotAmount();
	}

bool
PokerTableWnd::SetPotAmount(int nSeat, int nAmount, bool bRedraw /*= true*/){
	PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
	if( !pSeat )
		return false;

	int nAmountOld = pSeat->GetPotAmount();
	pSeat->SetPotAmount(nAmount);
	if( bRedraw ){
		Invalidate_Chips(nSeat, nAmountOld);
		}
	return true;
	}

int
PokerTableWnd::GetSeatTotalPot(int nSeat){
	PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
	if( !pSeat )
		return 0;
	return pSeat->GetTotalPot();
	}

bool
PokerTableWnd::SetSeatTotalPot(int nSeat, int nAmount, bool bRedraw /*= true*/){
	PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
	if( !pSeat )
		return false;

	int nAmountOld = pSeat->GetTotalPot();
	pSeat->SetTotalPot(nAmount);
	if( bRedraw ){
		Invalidate_Balance(nSeat);
		}
	return true;
	}

int
PokerTableWnd::GetBalance(int nSeat){
	PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
	if( !pSeat )
		return 0;
	return pSeat->GetBalance();
	}

bool
PokerTableWnd::SetBalance(int nSeat, int nBalance, bool bRedraw /*= true*/){
	PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
	if( !pSeat )
		return false;
	pSeat->SetBalance(nBalance);
	if( bRedraw ){
		Invalidate_Balance(nSeat);
		}
	return true;
	}

bool
PokerTableWnd::StartActionTimer(int nSeat, bool bStart /*= true*/, bool bInvalidate /*= false*/){
	PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
	if( !pSeat )
		return false;

	if( bStart ){ // Start
		// Stop recently active seat timer. {{
		if( m_pTimerActiveSeat ){
			int nSeatRecentlyActive = GetSeatIndex(m_pTimerActiveSeat);
			if( nSeatRecentlyActive != -1 ){
				m_pTimerActiveSeat->ActivateTimer(false);
				if( bInvalidate ){
					Invalidate_SeatTimer(nSeatRecentlyActive);
					}
				}
			}
		// }}

		pSeat->ActivateTimer(true);
		m_pTimerActiveSeat = pSeat; // Save timer active seat.

		// Set action timer.
		SetTimer(POKER_SEAT_ACTION_TIMER, 1000, NULL);
		}
	else{ // Stop
		pSeat->ActivateTimer(false);
		m_pTimerActiveSeat = NULL;

		// Kill action timer.
		KillTimer(POKER_SEAT_ACTION_TIMER);
		}

	if( bInvalidate ){
		Invalidate_SeatTimer(nSeat);
		}
	return true;
	}

void
PokerTableWnd::ClearPotAmounts(bool bRedraw /*= true*/){
	int nSeat		= 0;
	int nCt			= m_seats.GetCount();
	int nSumChips	= 0;

	while( nSeat < nCt ){
		PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
		if( !pSeat ){
			nSeat ++;
			continue;
			}
		int nAmountOld = pSeat->GetPotAmount();
		pSeat->SetTotalPot	(0);
		pSeat->SetPotAmount	(0);
		if( bRedraw ){
			Invalidate_Chips(nSeat, nAmountOld);
			}
		nSeat ++;
		}
	}

void
PokerTableWnd::CollectChips(){
	int nSeat		= 0;
	int nCt			= m_seats.GetCount();
	int nSumChips	= 0;

	while( nSeat < nCt ){
		PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
		if( !pSeat ){
			nSeat ++;
			continue;
			}
		int nAmountOld = pSeat->GetPotAmount();
		pSeat->SetPotAmount(0);
		Invalidate_Chips(nSeat, nAmountOld);
		nSeat ++;
		}
	}

void
PokerTableWnd::Anim_CollectChips(){
	int nSeat		= 0;
	int nCt			= m_seats.GetCount();
	int nSumChips	= 0;

	while( nSeat < nCt ){
		PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
		if( !pSeat ){
			nSeat ++;
			continue;
			}
		int nAmountOld = pSeat->GetPotAmount();
		nSumChips += 100;
		pSeat->SetPotAmount(nAmountOld - 100);
		Invalidate_Chips(nSeat, nAmountOld);
		nSeat ++;
		}

	int nAmountOld = m_nMainPotAmount;
	m_nMainPotAmount += nSumChips;
	Invalidate_MainPotChips(nAmountOld);
	}

void
PokerTableWnd::ClearSeatCards(bool bRedraw){
	int nSeat		= 0;
	int nCt			= m_seats.GetCount();
	int nSumChips	= 0;

	while( nSeat < nCt ){
		PokerTableSeatInfo* pSeat = m_seats.GetAt(nSeat);
		if( !pSeat ){
			nSeat ++;
			continue;
			}
		SetSeatCards(nSeat, -1, -1, -1, -1, bRedraw);
		nSeat ++;
		}
	}

void
PokerTableWnd::ClearTableCards(bool bRedraw){
	SetTableCards(-1, -1, -1, -1, -1, bRedraw);
	}

// ######################################################
//
//	Action methods.
//
// ######################################################

bool
PokerTableWnd::GetSeatPanelRect(int nSeat, CRect& rcSeat){
	if( !m_seatPanelInfos )
		return false;

	SeatPanelInfo* pSeatInfo = m_seatPanelInfos->GetAt(nSeat);
	if( !pSeatInfo ){
		return false;
		}

	rcSeat.left		= ( m_pGUI->m_ptTablePos.x + pSeatInfo->m_ptPos.x);
	rcSeat.top		= ( m_pGUI->m_ptTablePos.y + pSeatInfo->m_ptPos.y);
	rcSeat.right	= rcSeat.left + m_pGUI->m_szSeatPanel.cx;
	rcSeat.bottom	= rcSeat.top + m_pGUI->m_szSeatPanel.cy;
	return true;
	}

bool
PokerTableWnd::GetSeatCardsRect(int nSeat, CRect& rcCards){
	if( !m_seatPanelInfos )
		return false;

	SeatPanelInfo* pSeatInfo = m_seatPanelInfos->GetAt(nSeat);
	if( !pSeatInfo ){
		return false;
		}

	rcCards.left	= ( m_pGUI->m_ptTablePos.x + pSeatInfo->m_ptPos.x + m_pGUI->m_ptSeatCard1Pos.x);
	rcCards.top		= ( m_pGUI->m_ptTablePos.y + pSeatInfo->m_ptPos.y + m_pGUI->m_ptSeatCard1Pos.y);
	rcCards.right	= rcCards.left + (m_pGUI->m_ptSeatCard2Pos.x - m_pGUI->m_ptSeatCard1Pos.x + m_pGUI->m_szCardDimension.cx);
	rcCards.bottom	= rcCards.top + m_pGUI->m_szCardDimension.cy;
	return true;
	}

bool
PokerTableWnd::GetSeatPanelByPoint(CPoint pt, int& nSeat, CRect& rcSeatPanel){
	if( !m_seatPanelInfos )
		return false;

	int				nLoop = 0;
	CRect			rcSeat(0, 0, 0, 0);
	SeatPanelInfo*	pSeatInfo;

	while( nLoop < m_seatPanelInfos->GetCount() ){
		pSeatInfo = m_seatPanelInfos->GetAt(nLoop);
		if( !pSeatInfo ){
			nLoop ++;
			continue;
			}

		rcSeat.left		= ( m_pGUI->m_ptTablePos.x + pSeatInfo->m_ptPos.x);
		rcSeat.top		= ( m_pGUI->m_ptTablePos.y + pSeatInfo->m_ptPos.y);
		rcSeat.right	= rcSeat.left + m_pGUI->m_szSeatPanel.cx;
		rcSeat.bottom	= rcSeat.top + m_pGUI->m_szSeatPanel.cy;
		if( rcSeat.PtInRect(pt) ){
			rcSeatPanel = rcSeat;
			nSeat		= nLoop;
			return true; // Seat found.
			}
		nLoop ++;
		}

	return false;
	}

bool
PokerTableWnd::IsTimerActive(int nSeat){
	PokerTableSeatInfo* pSeat = GetSeatInfo(nSeat);
	if( !pSeat ) return false;
	return pSeat->IsTimerActive();
	}

bool
PokerTableWnd::SetActiveSeat(int nSeatIndex, bool bActivateTimer /*= false*/, bool bInvalidate){
	int nActiveSeatOld	= m_nActiveSeat;
	m_nActiveSeat		= nSeatIndex;

	// Stop action timer on old seat. {{
	if( IsTimerActive(nActiveSeatOld) ){
		StartActionTimer(nActiveSeatOld, false, bInvalidate);
		}
	// }}

	if( bActivateTimer ){
		StartActionTimer(nSeatIndex, true);
		}

	if( bInvalidate ){
		Invalidate_SeatPanel(nActiveSeatOld);
		Invalidate_SeatPanel(nSeatIndex);
		}
	return true;
	}

SeatPanelInfo*
PokerTableWnd::GetSeatPanelInfo(int nSeat){
	return m_seatPanelInfos->GetAt(nSeat);
	}

bool
PokerTableWnd::AddActionButton(ActionButton type, CString sLabel, int nAmountMin, int nAmountMax, bool bInvalidate /*= true*/){
	ActionButtonInfo* pNew	= new ActionButtonInfo();
	pNew->nAmountMin		= nAmountMin;
	pNew->nAmount			= min(nAmountMin, nAmountMax);
	pNew->nAmountMax		= nAmountMax;
	pNew->sLabel			= sLabel;
	pNew->type				= type;
	m_listActionButtons.Add(pNew);
	int	nActionButtonCt = m_listActionButtons.GetCount();

	ESChildControl*			pActionPanel	= GetChildControl(CHILD_PokerActionPanel);
	ESChildControlButton*	pActionButton	= new ESChildControlButton();
	CRect rcButton;
	rcButton.left			= (m_pGUI->m_ptActionButton.x) + (m_pGUI->m_szActionButton.cx + 5)*(nActionButtonCt-1);
	rcButton.top			= m_pGUI->m_ptActionButton.y;
	rcButton.right			= rcButton.left + m_pGUI->m_szActionButton.cx;
	rcButton.bottom			= rcButton.top + m_pGUI->m_szActionButton.cy;

	int nId					= CHILD_ActionButton + (nActionButtonCt - 1);
	pNew->nButtonId			= nId;
	AddChildControl(pActionButton, nId, rcButton, pActionPanel);
	pActionButton->SetText(sLabel, bInvalidate);
	return true;
	}

bool
PokerTableWnd::ClearActionButtons(bool bInvalidate /*= true*/){
	int nCt		= m_listActionButtons.GetCount();
	int nLoop	= 0;

	while( nLoop < nCt ){
		ESChildControl*	pActionButton = GetChildControl(CHILD_ActionButton + nLoop);
		if( pActionButton ){
			if( bInvalidate ){
				pActionButton->SetVisible(false, bInvalidate);
				}
			RemoveChildControl(pActionButton);
			}
		nLoop ++;
		}
	m_listActionButtons.RemoveAll();
	return true;
	}

bool
PokerTableWnd::RedrawActionButtons(){
	int nCt = m_listActionButtons.GetCount();
	if( !nCt )
		return false;
	
	int nLoop = 0;
	while( nLoop < nCt ){
		ESChildControl*	pActionButton = GetChildControl(CHILD_ActionButton + nLoop);
		if( pActionButton )
			pActionButton->Redraw();
		nLoop ++;
		}
	return true;
	}

bool
PokerTableWnd::SetActionButtonInfo(int nIndex, CString sLabel, int nAmount, bool bInvalidate){
	ActionButtonInfo* pInfo = m_listActionButtons.GetAt(nIndex);
	if( !pInfo )
		return false;

	pInfo->sLabel	= sLabel;
	pInfo->nAmount	= nAmount;

	ESChildControlButton*	pActionButton = (ESChildControlButton*)GetChildControl(CHILD_ActionButton + nIndex);
	if( pActionButton ){
		pActionButton->SetText(sLabel, false);
		}

	if( bInvalidate ){
		RedrawActionButton(nIndex);
		}
	return true;
	}

bool
PokerTableWnd::RedrawActionButton(int nIndex){
	ActionButtonInfo* pInfo = m_listActionButtons.GetAt(nIndex);
	if( !pInfo )
		return false;

	ESChildControl*	pActionButton = GetChildControl(CHILD_ActionButton + nIndex);
	if( !pActionButton )
		return false;	

	pActionButton->Redraw();
	return true;
	}

bool
PokerTableWnd::ClearActionLabels(bool bRedraw){
	int nLoop	= 0;
	int nCt		= m_nMaxPlayerCt;

	while( nLoop < nCt ){
		PokerTableSeatInfo* pSeatInfo = GetSeatInfo(nLoop);
		if( pSeatInfo ){
			pSeatInfo->SetActionName(_T(""));
			pSeatInfo->SetLastAction(PokerActionTypes::NoAction);
			if( bRedraw ){
				RedrawSeatActionLabel(nLoop);
				}
			}
		nLoop ++;
		}
	return true;
	}

bool
PokerTableWnd::SetSeatActionLabel(int nSeat, CString sActionName, bool bInvalidate /*= true*/){
	PokerTableSeatInfo* pSeatInfo = GetSeatInfo(nSeat);
	if( !pSeatInfo )
		return false;
	pSeatInfo->SetActionName(sActionName);
	if( bInvalidate )
		RedrawSeatActionLabel(nSeat);
	return true;
	}

bool
PokerTableWnd::RedrawSeatActionLabel(int nSeat){
	PokerTableSeatInfo* pInfo = GetSeatInfo(nSeat);
	if( !pInfo )
		return false;

	SeatPanelInfo* pPanelInfo = GetSeatPanelInfo(nSeat);
	if( !pPanelInfo )
		return false;

	CSize szText;
	CString sAction = pInfo->GetActionName();
	ImgHlp::GetTextSize(&sAction, m_pGUI->m_pSeatLabelFont, szText);

	CRect rcActionLabel;
	rcActionLabel.left		= pPanelInfo->m_ptPos.x + m_pGUI->m_ptSeatActionLabel.x;
	rcActionLabel.top		= pPanelInfo->m_ptPos.y + m_pGUI->m_ptSeatActionLabel.y;
	rcActionLabel.right		= rcActionLabel.left + szText.cx;
	rcActionLabel.bottom	= rcActionLabel.top + szText.cy;

	if( !rcActionLabel.IsRectEmpty() ){
		RedrawRect(rcActionLabel, 1);
		return true;
		}
	return false;
	}

bool
PokerTableWnd::SetSeatStatus(int nSeat, PokerSeatStatus status, bool bInvalidate /*= true*/){
	PokerTableSeatInfo* pSeat = GetSeatInfo(nSeat);
	if( !pSeat ) 
		return false;
	pSeat->SetStatus(status);
	if( bInvalidate ){
		Invalidate_SeatPanel(nSeat);
		}
	return true;
	}

PokerSeatStatus	
PokerTableWnd::GetSeatStatus(int nSeat){
	PokerTableSeatInfo* pSeat = GetSeatInfo(nSeat);
	if( !pSeat ) 
		return PokerSeatStatus::Empty;
	return pSeat->GetStatus();
	}

void
PokerTableWnd::SetSeatOffline(int nSeat, bool bOnline /*= false*/, bool bInvalidate /*= true*/){
	PokerTableSeatInfo* pSeat = GetSeatInfo(nSeat);
	if( !pSeat ) 
		return;

	pSeat->SetOffline(!bOnline);
	if( bInvalidate ){
		Invalidate_SeatPanel(nSeat);
		}
	}

bool
PokerTableWnd::GetSeatOffline(int nSeat){
	PokerTableSeatInfo* pSeat = GetSeatInfo(nSeat);
	if( !pSeat ) 
		return false;
	return pSeat->IsOffline();
	}

LRESULT	
PokerTableWnd::OnActionButtonClick(WPARAM wParam, LPARAM lParam){
	int nId = (int)wParam - CHILD_ActionButton;
	if( nId >= m_listActionButtons.GetCount() )
		return 0L;

	ActionButtonInfo* pInfo = m_listActionButtons.GetAt(nId);
	if( !pInfo )
		return 0L;

	if( m_pHandler )
		m_pHandler->OnActionButtonClicked(pInfo);
	return 0L;
	}

LRESULT	
PokerTableWnd::OnShortcutButtonClick(WPARAM wParam, LPARAM lParam){
	int nId = (int)wParam - CHILD_ShortcutButton;
	if( nId >= m_listShortcutButtons.GetCount() )
		return 0L;

	ShortcutButtonInfo* pInfo = m_listShortcutButtons.GetAt(nId);
	if( !pInfo )
		return 0L;

	if( SetSliderAmount(pInfo->nAmount, true) ){
		// Set raise/bet button info. {{
		CString sLabel;
		if( m_currentRound == PokerRoundType::PreFlop )
			sLabel.Format(_T("Raise %d.%02d"), pInfo->nAmount/100, pInfo->nAmount%100);
		else
			sLabel.Format(_T("Bet %d.%02d"), pInfo->nAmount/100, pInfo->nAmount%100);
		SetActionButtonInfo(2, sLabel, pInfo->nAmount, true);
		// }}
		}
	return 0L;
	}

LRESULT
PokerTableWnd::OnSliderPosChanged(WPARAM wParam, LPARAM lParam){
	ESChildControlSlider* pSlider = (ESChildControlSlider*)lParam;
	if( !pSlider )
		return 0L;

	int nAmount = (int)wParam;
	// Set raise button info. {{
	CString sLabel;
	if( m_currentRound == PokerRoundType::PreFlop )
		sLabel.Format(_T("Raise %d.%02d"), nAmount/100, nAmount%100);
	else
		sLabel.Format(_T("Bet %d.%02d"), nAmount/100, nAmount%100);
	SetActionButtonInfo(2, sLabel, nAmount, true);
	// }}
	return 0L;
	}

LRESULT
PokerTableWnd::OnPreActionChecked(WPARAM wParam, LPARAM lParam){
	int							nId			= wParam;
	ESChildControlPreAction*	pPreAction	= (ESChildControlPreAction*)lParam;
	if( !pPreAction )			return 0L;
	bool						bCheckState = pPreAction->GetCheck();
	PreActionButtonInfo*		pInfo		= GetPreActionInfo(nId);
	if( pInfo && m_pHandler ){
		m_pHandler->OnPreActionButtonChecked(pInfo, bCheckState);
		//RemovePreActionButton(pInfo->type, true);
		//SetPreActionButtonLabel(pInfo->type, _T("Changed"), true);
		//ClearPreActions();
		}
	return 0L;
	}

bool
PokerTableWnd::AddShortcutButton(CString sLabel, int nAmount, bool bInvalidate /*= true*/){
	ShortcutButtonInfo* pInfo = new ShortcutButtonInfo();
	pInfo->sLabel		= sLabel;
	pInfo->nAmount		= nAmount;
	pInfo->nButtonId	= m_listShortcutButtons.GetCount();
	m_listShortcutButtons.Add(pInfo);

	ESChildControl*				pActionPanel	= GetChildControl(CHILD_PokerActionPanel);
	ESChildControlShortcutBtn*	pShortcutButton	= new ESChildControlShortcutBtn();
	
	CRect rcButton;
	rcButton.left			= (m_pGUI->m_ptShortcutButton.x) + (m_pGUI->m_szShortcutButton.cx + 2)*pInfo->nButtonId;
	rcButton.top			= m_pGUI->m_ptShortcutButton.y;
	rcButton.right			= rcButton.left + m_pGUI->m_szShortcutButton.cx;
	rcButton.bottom			= rcButton.top + m_pGUI->m_szShortcutButton.cy;

	pInfo->nButtonId		+= CHILD_ShortcutButton;
	AddChildControl(pShortcutButton, pInfo->nButtonId, rcButton, pActionPanel);
	pShortcutButton->SetText(sLabel, bInvalidate);
	return true;
	} 

bool
PokerTableWnd::ClearShortcutButtons(bool bInvalidate /*= true*/){
	int nCt		= m_listShortcutButtons.GetCount();
	int nLoop	= 0;

	while( nLoop < nCt ){
		ESChildControl*	pShortcutButton = GetChildControl(CHILD_ShortcutButton + nLoop);
		if( pShortcutButton ){
			if( bInvalidate ){
				pShortcutButton->SetVisible(false, bInvalidate);
				}
			RemoveChildControl(pShortcutButton);
			}
		nLoop ++;
		}
	m_listShortcutButtons.RemoveAll();
	return true;
	}

bool
PokerTableWnd::RedrawShortcutButtons(){
	int nCt		= m_listShortcutButtons.GetCount();
	int nLoop	= 0;

	while( nLoop < nCt ){
		ESChildControl*	pShortcutButton = GetChildControl(CHILD_ShortcutButton + nLoop);
		if( pShortcutButton ){
			pShortcutButton->Redraw();
			}
		nLoop ++;
		}
	return true;
	}

bool
PokerTableWnd::SetSliderAmount(int nAmount, bool bInvalidate /*= true*/){
	ESChildControlSlider*	pSlider			= (ESChildControlSlider*)GetChildControl(CHILD_Slider);
	if( !pSlider )
		return false;
	return pSlider->SetSliderPos(nAmount, bInvalidate);
	}

bool
PokerTableWnd::ShowSlider(int nAmount, int nAmountMin, int nAmountMax, int nAmountStep, bool bInvalidate /*= true*/){
	ESChildControl*			pActionPanel	= GetChildControl(CHILD_PokerActionPanel);
	ESChildControlSlider*	pSlider			= (ESChildControlSlider*)GetChildControl(CHILD_Slider);
	if( !pSlider ){
		pSlider	= new ESChildControlSlider();

		CRect rcSlider;
		rcSlider.left			= m_pGUI->m_ptSlider.x;
		rcSlider.top			= m_pGUI->m_ptSlider.y;
		rcSlider.right			= rcSlider.left + m_pGUI->m_szSlider.cx;
		rcSlider.bottom			= rcSlider.top + m_pGUI->m_szSlider.cy;

		AddChildControl(pSlider, CHILD_Slider, rcSlider, pActionPanel);
		}

	pSlider->SetupSlider	(nAmountMin, nAmountMax, nAmountStep, false);
	pSlider->SetSliderPos	(nAmount, false);
	pSlider->SetVisible		(true, false);
	if( bInvalidate )
		pSlider->Redraw();
	return true;
	}

bool
PokerTableWnd::HideSlider(bool bInvalidate /*= true*/){
	ESChildControl*		pSlider	= GetChildControl(CHILD_Slider);
	if( !pSlider ) return false;
	pSlider->SetVisible(false, bInvalidate);
	return true;
	}

bool
PokerTableWnd::AddPreActionButton(PreActionButton preAction, int nValue, CString sLabel, bool bCheckState, bool bInvalidate){
	PokerGUI* pGUI = PokerGUI::GetInstance();
	CPoint pos;
	if( !pGUI->GetPreActionPosition(preAction, pos) )
		return false;

	ESChildControl*				pChildExisted	= GetChildControl(CHILD_PreAction + (int)preAction);
	if( pChildExisted ){
		int nId		= pChildExisted->GetId();
		int nLoop	= 0;
		int nCt		= m_listPreActions.GetCount();

		while( nLoop < nCt ){
			PreActionButtonInfo* pInfo = m_listPreActions[nLoop];
			if( pInfo && pInfo->nButtonId == nId ){
				pInfo->nValue = nValue;
				pInfo->sLabel = sLabel;
				break;
				}
			nLoop ++;
			}

		pChildExisted->SetVisible(true, false);
		((ESChildControlPreAction*)pChildExisted)->SetCheck(bCheckState, false);
		((ESChildControlPreAction*)pChildExisted)->SetText(sLabel, bInvalidate);
		return true;
		}

	ESChildControl*				pActionPanel	= GetChildControl(CHILD_PokerActionPanel);
	ESChildControlPreAction*	pPreAction		= new ESChildControlPreAction();
	ESChildControl*				pParent			= NULL;

	PreActionButtonInfo* pInfo = new PreActionButtonInfo();
	pInfo->sLabel		= sLabel;
	pInfo->type			= preAction;
	pInfo->nButtonId	= CHILD_PreAction + (int)preAction;
	pInfo->ptPos		= pos;
	pInfo->nValue		= nValue;	
	m_listPreActions.Add(pInfo);

	CRect rcPreAction;
	rcPreAction.left		= pos.x;
	rcPreAction.top			= pos.y;
	rcPreAction.right		= rcPreAction.left + m_pGUI->m_szPreAction.cx;
	rcPreAction.bottom		= rcPreAction.top + m_pGUI->m_szPreAction.cy;

	if( pActionPanel->GetClientRect().PtInRect(pos) ){
		pParent = pActionPanel;
		}

	AddChildControl(pPreAction, pInfo->nButtonId, rcPreAction, pParent);
	pPreAction->SetCheck	(bCheckState, false);
	pPreAction->SetText		(sLabel, false);
	pPreAction->SetVisible	(true, bInvalidate);
	return true;
	}

bool
PokerTableWnd::RemovePreActionButton(PreActionButton preAction, bool bInvalidate){
	ESChildControl*	 pPreAction	= GetChildControl(CHILD_PreAction + (int)preAction);
	if( !pPreAction ){
		return false;
		}

	int nId		= pPreAction->GetId();
	int nLoop	= 0;
	int nCt		= m_listPreActions.GetCount();

	while( nLoop < nCt ){
		PreActionButtonInfo* pInfo = m_listPreActions[nLoop];
		if( pInfo && pInfo->nButtonId == nId ){
			m_listPreActions.RemoveAt(nLoop);
			break;
			}
		nLoop ++;
		}

	pPreAction->SetVisible(false, bInvalidate);
	RemoveChildControl(pPreAction);
	return true;
	}

bool
PokerTableWnd::SetPreActionButtonLabel(PreActionButton preAction, CString sLabel, bool bInvalidate /*= true*/){
	ESChildControlPreAction*	 pPreAction	= (ESChildControlPreAction*)GetChildControl(CHILD_PreAction + (int)preAction);
	if( !pPreAction ){
		return false;
		}
	int						nId		= pPreAction->GetId();
	PreActionButtonInfo*	pInfo	= GetPreActionInfo(nId);
	if( !pInfo )
		return false;

	pInfo->sLabel = sLabel;
	pPreAction->SetText(sLabel, bInvalidate);
	return true;
	}

bool
PokerTableWnd::SetPreActionCheckState(PreActionButton preAction, bool bCheckState, bool bInvalidate /*= true*/){
	ESChildControlPreAction*	 pPreAction	= (ESChildControlPreAction*)GetChildControl(CHILD_PreAction + (int)preAction);
	if( !pPreAction ){
		return false;
		}
	pPreAction->SetCheck(bCheckState, bInvalidate);
	return true;
	}

bool
PokerTableWnd::GetPreActionCheckState(PreActionButton preAction){
	ESChildControlPreAction*	 pPreAction	= (ESChildControlPreAction*)GetChildControl(CHILD_PreAction + (int)preAction);
	if( !pPreAction )
		return false;
	return pPreAction->GetCheck();
	}

bool
PokerTableWnd::ClearPreActions(bool bInvalidate /*= true*/){
	int nLoop	= 0;
	int nCt		= m_listPreActions.GetCount();

	while( nLoop < nCt ){
		PreActionButtonInfo* pInfo = m_listPreActions[nLoop];
		if( pInfo ){
			ESChildControlPreAction*	 pPreAction	= (ESChildControlPreAction*)GetChildControl(pInfo->nButtonId);
			if( pPreAction ){
				pPreAction->SetVisible(false, bInvalidate);
				RemoveChildControl(pPreAction);
				}
			}
		nLoop ++;
		}
	return true;
	}

bool
PokerTableWnd::RedrawPreActions(){
	int nLoop	= 0;
	int nCt		= m_listPreActions.GetCount();

	while( nLoop < nCt ){
		PreActionButtonInfo* pInfo = m_listPreActions[nLoop];
		if( pInfo ){
			ESChildControlPreAction* pPreAction	= (ESChildControlPreAction*)GetChildControl(pInfo->nButtonId);
			if( pPreAction ){
				pPreAction->Redraw();
				}
			}
		nLoop ++;
		}
	return true;
	}

bool
PokerTableWnd::RedrawPreActionButton(PreActionButton preAction){
	ESChildControlPreAction* pPreAction	= (ESChildControlPreAction*)GetChildControl(CHILD_PreAction + (int)preAction);
	if( pPreAction ){
		pPreAction->Redraw();
		return true;
		}
	return false;
	}

PreActionButtonInfo*
PokerTableWnd::GetPreActionInfo(int nId){
	int nLoop	= 0;
	int nCt		= m_listPreActions.GetCount();

	while( nLoop < nCt ){
		PreActionButtonInfo* pInfo = m_listPreActions[nLoop];
		if( pInfo && pInfo->nButtonId == nId ){
			return pInfo;
			}
		nLoop ++;
		}
	return NULL;
	}